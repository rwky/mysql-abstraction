// Generated by CoffeeScript 1.12.3
var async, events, mysql,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

mysql = require('mysql');

events = require('events');

async = require('async');

module.exports = function(settings) {
  var Connection, pool;
  pool = mysql.createPool(settings);
  return {
    pool: pool,
    connection: Connection = (function(superClass) {
      extend(Connection, superClass);

      function Connection(autoStartTransaction) {
        this.autoStartTransaction = autoStartTransaction != null ? autoStartTransaction : false;
        this.gatherStats = true;
        this.log = false;
        this.logs = [];
        this.maxRetries = 3;
        this._reset();
      }

      Connection.prototype._reset = function() {
        this.hasTransaction = false;
        this.connection = null;
        this.logs = [];
        this._returnConnection = null;
        this.queries = [];
        this.retries = 0;
        this.lastQuery = null;
        this.lastOps = null;
        return this.stats = {
          select: 0,
          update: 0,
          "delete": 0,
          insert: 0
        };
      };

      Connection.prototype.connect = function(cb) {
        this._returnConnection = (function(_this) {
          return function(err, connection) {
            _this.connection = connection;
            if (err) {
              _this.emit('error', err);
            }
            return cb(err);
          };
        })(this);
        return pool.getConnection(this._returnConnection);
      };

      Connection.prototype.error = function(err, cb) {
        var end;
        err.query = this.lastQuery;
        if (err.code === 'ER_LOCK_DEADLOCK' && this.retries < this.maxRetries) {
          this.retries += 1;
          this.emit('deadlock', err);
          this.hasTransaction = false;
          return async.eachSeries(this.queries, (function(_this) {
            return function(query, c) {
              return _this.q({
                q: query.q,
                params: query.params,
                retry: true,
                cb: c
              });
            };
          })(this), cb);
        }
        if (settings.logErrors != null) {
          settings.logErrors(err);
        }
        end = (function(_this) {
          return function() {
            _this.emit('error', err);
            if (cb != null) {
              return cb(err);
            }
          };
        })(this);
        if (this.connection) {
          return this.connection.query('ROLLBACK', (function(_this) {
            return function(err) {
              _this.connection._purge = true;
              _this.connection.release();
              _this.connection = null;
              return end();
            };
          })(this));
        } else {
          return process.nextTick(end);
        }
      };

      Connection.prototype.q = function(ops) {
        var query, run;
        if (this.log) {
          this.logs.push(ops);
        }
        this.lastOps = ops;
        query = (function(_this) {
          return function() {
            var i, len, ref, stat, streamError;
            ops.cb = ops.cb || ops.callback;
            ops.values = ops.values || ops.params || [];
            ops.sql = ops.sql || ops.q;

            /*
            #This is crude and doesn't support complex queries i.e. UPDATE .... SELECT
            #But it does the job for most cases
             */
            if (_this.gatherStats) {
              ref = Object.keys(_this.stats);
              for (i = 0, len = ref.length; i < len; i++) {
                stat = ref[i];
                if (ops.sql.toLowerCase().indexOf(stat) !== -1) {
                  _this.stats[stat] += 1;
                }
              }
            }
            streamError = null;
            if (ops.lock != null) {
              ops.sql += ops.lock === 1 ? ' LOCK IN SHARE MODE' : ' FOR UPDATE';
            }
            if (!ops.retry) {
              _this.queries.push({
                q: ops.q,
                params: ops.params
              });
            }
            if (ops.stream != null) {
              _this.lastQuery = query = _this.connection.query(ops.sql, ops.params);
              query.on('error', function(err) {
                return streamError = err;
              });
              query.on('result', function(row) {
                return ops.stream(row);
              });
              return query.on('end', function() {
                if (streamError != null) {
                  return _this.error(streamError, ops.cb);
                }
                return ops.cb();
              });
            } else {
              return _this.lastQuery = _this.connection.query(ops, function(err, data) {
                if (ops.warningsAreErrors && (data != null ? data.warningCount : void 0) > 0) {
                  return _this.connection.query('SHOW WARNINGS', function(err, warnings) {
                    var error;
                    if (err) {
                      return _this.error(err, ops.cb);
                    } else {
                      error = new Error('Warnings treated as errors ' + data.warningCount);
                      error.warnings = warnings;
                      return _this.error(error, ops.cb);
                    }
                  });
                } else if (err) {
                  return _this.error(err, ops.cb);
                } else {
                  return ops.cb(null, data);
                }
              });
            }
          };
        })(this);
        run = (function(_this) {
          return function() {
            if (!_this.hasTransaction && (_this.autoStartTransaction || (ops.lock != null))) {
              return _this.begin(function() {
                return query();
              });
            } else {
              return query();
            }
          };
        })(this);
        if (this.connection == null) {
          return this.connect(function() {
            return run();
          });
        } else {
          return run();
        }
      };

      Connection.prototype.row = function(ops) {
        var cb, ref;
        cb = ops.cb;
        ref = [
          ops.cb, function(err, data) {
            return cb(err, data[0]);
          }
        ], cb = ref[0], ops.cb = ref[1];
        return this.q(ops);
      };

      Connection.prototype.count = function(ops) {
        var cb, ref;
        cb = ops.cb;
        ref = [
          ops.cb, function(err, data) {
            return cb(err, data[0][Object.keys(data[0])[0]]);
          }
        ], cb = ref[0], ops.cb = ref[1];
        return this.q(ops);
      };

      Connection.prototype.begin = function(cb) {
        this.hasTransaction = true;
        return this.q({
          q: 'START TRANSACTION',
          cb: function() {
            return cb();
          }
        });
      };

      Connection.prototype.commit = function(ops, cb) {
        var ref;
        if (cb == null) {
          ref = [ops, {}], cb = ref[0], ops = ref[1];
        }
        return this.q({
          q: 'COMMIT',
          timeout: ops.timeout,
          cb: (function(_this) {
            return function() {
              _this.hasTransaction = false;
              return cb();
            };
          })(this)
        });
      };

      Connection.prototype.end = function(ops, cb) {
        var index;
        if (arguments.length === 1) {
          cb = ops;
          ops = {};
        }
        if (this.connection == null) {
          index = pool._connectionQueue.indexOf(this._returnConnection);
          if (index !== -1) {
            pool._connectionQueue.splice(index, 1);
          }
          this._reset();
          return process.nextTick(cb);
        } else if (this.hasTransaction) {
          return this.commit(ops, (function(_this) {
            return function(err) {
              _this.connection.release();
              _this._reset();
              return cb(err);
            };
          })(this));
        } else {
          this.connection.release();
          this._reset();
          return process.nextTick(cb);
        }
      };

      Connection.prototype.batch = function(queries, cb) {
        var executed, results, run;
        if (queries.length === 0) {
          return this.error(new Error("Cannot batch 0 queries"), cb);
        }
        results = [];
        executed = 1;
        run = (function(_this) {
          return function(err, res) {
            results.push(res);
            if (err) {
              return cb(err, results);
            }
            if (queries.length > executed) {
              queries[executed].cb = run;
              _this.q(queries[executed]);
              return executed += 1;
            } else {
              return cb(null, results);
            }
          };
        })(this);
        queries[0].cb = run;
        return this.q(queries[0]);
      };

      return Connection;

    })(events.EventEmitter)
  };
};
